
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>React Jogo da velha</title>
  <script src="https://geovanisouza92.github.io/codelabs/bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <link rel="import" href="https://geovanisouza92.github.io/codelabs/elements/codelab.html">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <style is="custom-style">
    body {
      font-family: "Roboto",sans-serif;
      background: var(--google-codelab-background, #F8F9FA);
    }
  </style>
  
</head>
<body unresolved class="fullbleed">

  <google-codelab title="React Jogo da velha"
                  environment="web"
                  feedback-link="https://github.com/geovanisouza92/codelabs/issues">
    
      <google-codelab-step label="Antes de come√ßarmos" duration="0">
        <p>Hoje vamos criar um jogo da velha interativo.</p>
<p>Se quiser, pode visualizar o resultado final <a href="http://todo" target="_blank">aqui</a>. N√£o se preocupe se o c√≥digo ainda n√£o fizer sentido para voc√™, ou se ele usa uma sintaxe n√£o familiar. Vamos aprender como criar esse jogo, passo a passo, atrav√©s desse tutorial.</p>
<p>Comece jogando o jogo. Voc√™ pode clicar no bot√£o de &#34;Desfazer&#34; e ver como o tabuleiro era antes do movimento ser executado.</p>
<p>Quando voc√™ se tornar familiar com o jogo, fique a vontade para fechar a aba, pois vamos come√ßar com um modelo mais simples nas pr√≥ximas se√ß√µes.</p>
<h2><strong>Pr√©-requisitos</strong></h2>
<p>Vamos assumir que voc√™ tem familiaridade com HTML e JavaScript, mas se voc√™ deve ser capaz de seguir em frente mesmo que voc√™ n√£o os tenha usado antes.</p>
<p>Se voc√™ precisa de uma revis√£o de JavaScript, recomendamos <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank">esse guia</a>. Note que vamos usar funcionalidades do ES6, uma vers√£o recente do JavaScript. Nesse tutorial, we&#39;re using <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank">fun√ß√µes de seta</a>, <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Classes" target="_blank">classes</a>, <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Statements/let" target="_blank">let</a> e <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Statements/const" target="_blank">const</a>.</p>
<h2><strong>Como seguir adiante</strong></h2>
<p>H√° duas formas de completar esse tutorial: voc√™ pode escrever o c√≥digo diretamente no navegador (recomendado), ou voc√™ pode configurar um ambiente de desenvolvimento na sua m√°quina. Voc√™ pode escolher a op√ß√£o com a qual se sentir mais confort√°vel.</p>
<h2><strong>Se preferir escrever o c√≥digo no navegador</strong></h2>
<p>Este √© o jeito mais r√°pido de come√ßar!</p>
<p>Primeiro, abra <a href="https://stackblitz.com/edit/react-jogo-da-velha" target="_blank">este c√≥digo inicial</a> em uma nova aba. Ele deve mostrar um jogo da velha vazio. N√≥s vamos editar este c√≥digo durante este tutorial.</p>
<p>Voc√™ pode pular dessa se√ß√£o de como configurar o ambiente local direto para a Vis√£o geral.</p>
<h2><strong>Se preferir escrever o c√≥digo no navegador</strong></h2>
<p>Alternativamente, voc√™ pode configurar esse projeto no seu computador.</p>
<aside class="warning"><p>Isso √© completamente opcional e n√£o √© requisito para este tutorial!</p>
</aside>
<p>Isso d√° mais trabalho, mas permite que voc√™ aproveite o conforto do seu editor.</p>
<p>Se voc√™ quer faz√™-lo, aqui est√£o os passos necess√°rios:</p>
<p>- Tenha certeza que tem uma vers√£o do <a href="https://nodejs.org/en/" target="_blank">Node.js</a> instalado.</p>
<p>- Siga as <a href="https://reactjs.org/docs/add-react-to-a-new-app.html" target="_blank">instru√ß√µes de instala√ß√£o</a> para criar um novo projeto.</p>
<pre><code>npm install -g create-react-app
create-react-app meu-jogo-da-velha</code></pre>
<p>- Apague todos os arquivos da pasta <code>src/</code> (n√£o apague a pasta, apenas o conte√∫do).</p>
<pre><code>cd meu-jogo-da-velha
rm -f src/*</code></pre>
<p>- Adicione um arquivo <code>style.css</code> na pasta <code>src/</code> com <a href="https://stackblitz.com/edit/react-jogo-da-velha?embed=1&file=style.css&view=editor" target="_blank">esse c√≥digo CSS</a>.</p>
<p>- Adicione um arquivo <code>index.js</code> na pasta <code>src/</code> com <a href="https://stackblitz.com/edit/react-jogo-da-velha?embed=1&file=index.js&view=editor" target="_blank">esse c√≥digo JS</a>.</p>
<p>Agora se voc√™ executar </p>
<pre>npm start</pre>
<p>na pasta do projeto e abrir <a href="http://localhost:3000" target="_blank">http://localhost:3000</a> no navegador, deve ver um jogo da velha em branco.</p>
<h2><strong>Me ajuda, fiquei preso(a)!</strong></h2>
<p>Se voc√™ ficar preso em algum passo, pe√ßa ajuda no <a href="https://classroom.google.com/c/MTExODQ5OTA1MTVa" target="_blank">f√≥rum da aula</a>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Vis√£o geral" duration="0">
        <h2><strong>O que √© React?</strong></h2>
<p>React √© uma biblioteca JavaScript declarativa, eficiente e flex√≠vel para criar interfaces de usu√°rio.</p>
<p>React tem diferentes tipos de componentes, mas vamos come√ßar com subclasses de React.Component:</p>
<pre><code>class ShoppingList extends React.Component {
  render() {
    return (
      &lt;div className=&#34;shopping-list&#34;&gt;
        &lt;h1&gt;Lista de compras para {this.props.name}&lt;/h1&gt;
        &lt;ul&gt;
          &lt;li&gt;Instagram&lt;/li&gt;
          &lt;li&gt;WhatsApp&lt;/li&gt;
          &lt;li&gt;Oculus&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    );
  }
}

// Examplo de uso: &lt;ShoppingList name=&#34;Mark&#34; /&gt;</code></pre>
<p>J√° vamos chegar nessas tags XML engra√ßadas num momento. Seu componente diz ao React o que voc√™ quer renderizar - ent√£o o React vai eficientemente atualizar e renderizar os componentes apenas quando seus dados mudarem.</p>
<p>Aqui, <code>ShoppingList</code> √© uma classe componente React, ou um tipo de componente React. Um componente recebe par√¢metros, chamados <em>props</em> (propriedades), e retorna uma hierarquia de elementos para exibir atrav√©s do m√©todo <code>render</code>.</p>
<p>O m√©todo <code>render</code> retorna uma descri√ß√£o do que voc√™ quer renderizar, e ent√£o o React toma essa descri√ß√£o e a renderiza na tela. Em particular, o m√©todo <code>render</code> retorna um <em>React element</em>, que √© uma descri√ß√£o simplificada do que renderizar. A maioria dos desenvolvedores React usam uma sintaxe especial chamada <em>JSX </em>que torna mais simples escrever essas estruturas. A sintaxe <code>&lt;div/&gt;</code> √© transformada em tempo de compila√ß√£o em <code>React.createElement(‚Äòd</code>iv&#39;). O exemplo acima √© equivalente a:</p>
<pre><code>return React.createElement(&#39;div&#39;, {className: &#39;shopping-list&#39;},
  React.createElement(&#39;h1&#39;, /* ... filhos do h1 ... */),
  React.createElement(&#39;ul&#39;, /* ... filhos do ul ... */)
);</code></pre>
<p><a href="https://babeljs.io/repl/#?presets=react&code_lz=DwEwlgbgBAxgNgQwM5IHIILYFMC8AiJACwHsAHUsAOwHMBaOMJAFzwD4AoKKYQgRlYDKJclWpQAMoyZQAZsQBOUAN6l5ZJADpKmLAF9gAej4cuwAK5wTXbg1YBJSswTV5mQ7c7XgtgOqEETEgAguTuYFamtgDyMBZmSGFWhhYchuAQrADc7EA" target="_blank"><paper-button class="colored" raised>Veja a vers√£o completa aqui</paper-button></a></p>
<p>Se voc√™ est√° curioso, <code>createElement()</code> √© descrito em mais detalhes na refer√™ncia da API, mas n√£o vamos us√°-lo diretamente neste tutorial. Ao inv√©s, vamos continuar usando <em>JSX</em>.</p>
<p>Voc√™ pode inserir qualquer express√£o JavaScript entre chaves dentro do <em>JSX</em>. Cada elemento React √© um objeto JavaScript real onde voc√™ pode adicionar vari√°veis e pass√°-lo atrav√©s do seu programa.</p>
<p>O componente <code>ShoppingList</code> apenas renderiza elementos DOM padr√£o, mas voc√™ pode criar elementos customizados com React t√£o facilmente, ao escrever <code>&lt;ShoppingList/&gt;</code>. Cada componente √© encapsulado e pode operar independentemente, o que permite consturir interfaces de usu√°rio (UI) complexas a partir de componentes simples.</p>
<h2><strong>Come√ßando</strong></h2>
<p>Come√ße com esse examplo: <a href="https://stackblitz.com/edit/react-jogo-da-velha" target="_blank">c√≥digo inicial</a>.</p>
<p>Ele cont√©m a estrutura do que vamos construir hoje. N√≥s j√° fornecemos os estilos, ent√£o voc√™ s√≥ precisa se preocupar com o JavaScript.</p>
<p>Em especial, temos tr√™s componentes:</p>
<ul>
<li>Square</li>
<li>Board</li>
<li>Game</li>
</ul>
<p>O componente <em>Square</em> (quadrado) renderiza um simples <code>&lt;button&gt;</code>, o <em>Board</em> (tabuleiro) renderiza 9 quadrados, e o componente <em>Game</em> (jogo) renderiza o tabuleiro com alguns espa√ßos que vamos preencher depois. Nenhum desses componentes √© interativo nesse momento.</p>
<h2><strong>Passando dados atrav√©s de props</strong></h2>
<p>Apenas para se molhar, vamos tentar passar alguns dados para do componente <em>Board</em> para o componente <em>Square</em>:</p>
<pre><code>class Board extends React.Component {
  renderSquare(i) {
    Return &lt;Square value={i} /&gt;;
  }</code></pre>
<p>Ent√£o modificar o m√©todo <em>render</em> do componente <em>Square</em> para mostrar o valor substituindo <code>{/* TODO */}</code> com <code>{this.props.value}</code>.</p>
<pre><code>class Square extends React.Component {
  render() {
    return (
      &lt;button className=&#34;square&#34;&gt;
        {this.props.value}
      &lt;/button&gt;
    )
  }
}</code></pre>
<p>Antes:</p>
<p><img style="max-width: 254.00px" src="img/954d18c14976c42c.png"></p>
<p>Depois: Voc√™ pode ver o n√∫mero de cada quadrado na sa√≠da renderizada.</p>
<p><img style="max-width: 270.00px" src="img/3cb3b9814369ee27.png"></p>
<h2><strong>Um componente interativo</strong></h2>
<p>Vamos mudar o componente <em>Square</em> preenchendo um &#34;X&#34; quando voc√™ clica nele. Tente modificar a tag button retornada no m√©todo <code>render()</code> do <em>Square</em> desse jeito:</p>
<pre><code>class Square extends React.Component {
  render() {
    return (
      &lt;button className=&#34;square&#34; onClick={() =&gt; alert(&#39;click&#39;)}&gt;
        {this.props.value}
      &lt;/button&gt;
    );
  }
}</code></pre>
<p>Se voc√™ clicar no quadrado agora, voc√™ deve ver um alerta no navegador.</p>
<p>Isso usa a nova sintaxe do JavaScript para <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank">fun√ß√£o de seta</a>. Repare que estamos passando uma fun√ß√£o na propriedade <code>onClick</code>. Ao clicar, um alerta vai aparecer imediatamente ao inv√©s do clique do bot√£o.</p>
<p>Componentes React podem ter um estado ao definir <code>this.state</code> no construtor, que deve ser considerado privado ao componente. Vamos armazenar o valor do quadrado no estado, e modific√°-lo quando o bot√£o √© clicado.</p>
<pre><code>class Square extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: null,
    };
  }

  render() {
    return (
      &lt;button className=&#34;square&#34; onClick={() =&gt; alert(&#39;click&#39;)}&gt;
        {this.props.value}
      &lt;/button&gt;
    );
  }
}</code></pre>
<p>Em <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Classes" target="_blank">classes</a> JavaScript, voc√™ precisa chamar o <code>super();</code> explicitamente ao definir uma subclasse.</p>
<p>Agora mude o m√©todo <code>render</code> do <em>Square</em> para exibir o valor atual do estado, e modific√°-lo ao clicar.</p>
<ul>
<li>Substitua <code>this.props.value</code> com <code>this.state.value</code> dentro da tag <code>&lt;button&gt;</code>.</li>
<li>Substitua o <code>() =&gt; alert()</code> com <code>() =&gt; this.setState({ value: ‚Äò</code>X&#39; }).</li>
</ul>
<p>Agora o <code>&lt;button&gt;</code> se parece com isso:</p>
<pre><code>class Square extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: null,
    };
  }

  render() {
    return (
      &lt;button className=&#34;square&#34; onClick={() =&gt; this.setState({value: &#39;X&#39;})}&gt;
        {this.state.value}
      &lt;/button&gt;
    );
  }
}</code></pre>
<p>Sempre que <code>this.setState</code> √© chamado, um update ao componente √© agendado, fazendo o React combinar a atualiza√ß√£o de estado passado e renderizar o componente junto com seus descendentes. Quando o componente re-renderiza, <code>this.props.value</code> var ser <code>‚</code>ÄòX&#39; ent√£o voc√™ ver√° um X na grade.</p>
<p>Se voc√™ clicar em qualquer quadrado, um X deve aparecer nele.</p>
<h2><strong>Ferramentas de desenvolvimento</strong></h2>
<p>A extens√£o para Chrome e Firefox React Devtools permite que voc√™ inspecione uma √°rvore de componentes no seu navegador.</p>
<p><img style="max-width: 364.00px" src="img/bfd4e4a8dd98d4f1.png"></p>
<p>Isso lhe permite inspecionar props e estado de qualquer componente na √°rvore.</p>
<p>Depois de instal√°-la, voc√™ pode clicar em qualquer parte da p√°gina, clicar em &#34;Inspecionar&#34; para abrir as ferramentas de desenvolvimento, e a aba React vai aparecer como a √∫ltima da direita.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Levando o estado acima" duration="0">
        <p>Temos agora os blocos b√°sicos para criar o jogo da velha. Mas agora, o estado est√° encapsulado em cada componente <em>Square</em>. Para faz√™-lo funcionar corretamente, temos que checar se um jogador ganhou, e alternar o preenchimento com X e O nos quadrados. Para verificar se algu√©m ganhou, vamos ter o valor de todos os 9 quadrados em um lugar, ao inv√©s de dividi-lo em cada componente <em>Square</em>.</p>
<p>Voc√™ deve pensar que o <em>Board</em> s√≥ pergunta o estado atual de cada <em>Square</em>. Apesar disso ser tecnicamente poss√≠vel com React, √© desencorajado, pois isso tende a tornar o c√≥digo dif√≠cil de entender, mais fr√°gil, e dif√≠cil de refatorar.</p>
<p>Ao inv√©s disso, a melhor solu√ß√£o √© armazenar o estado no componente <em>Board</em> ao inv√©s de cada <em>Square</em> - e o componente <em>Board</em> pode chamar cada <em>Square</em> para exib√≠-lo, como fizemos cada um exibir seu √≠ndice antes.</p>
<p><strong>Quando voc√™ quer agregas dados de v√°rios filhos ou quer comunicar dois componentes entre eles, mova o estado para o componente pai. O pai ent√£o passa o estado de volta para cada filho via props, ent√£o o componente filho vari sempre estar sincronizado com cada outro do seu pai.</strong></p>
<p>Empurrando o estado acima √© comum quando refatorar componentes React, ent√£o vamos tomar a oportunidade para tentar. Adicione um construtor ao <em>Board</em> e defina seu estado inicial como uma lista contendo 9 <em>nulls</em>, correspondendo a cada um dos 9 quadrados:</p>
<pre><code>class Board extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      squares: Array(9).fill(null),
    };
  }

  renderSquare(i) {
    return &lt;Square value={i} /&gt;;
  }

  render() {
    const status = &#39;Pr√≥ximo jogador: X&#39;;

    return (
      &lt;div&gt;
        &lt;div className=&#34;status&#34;&gt;{status}&lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        &lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        &lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<p>N√≥s vamos preench√™-lo depois de tal forma que o <em>board</em> se pare√ßa com</p>
<pre><code>[
  &#39;O&#39;, null, &#39;X&#39;,
  &#39;X&#39;, &#39;X&#39;, &#39;O&#39;,
  &#39;O&#39;, null, null,
]</code></pre>
<p>O m√©todo <code>renderSquare</code> do <em>Board</em> se parece com isso:</p>
<pre><code>  renderSquare(i) {
    return &lt;Square value={i} /&gt;;
  }</code></pre>
<p>Modifique-o e passe uma prop <code>value</code> para o <em>Square</em>.</p>
<pre><code>  renderSquare(i) {
    return &lt;Square value={this.state.squares[i]} /&gt;;
  }</code></pre>
<p>Agora voc√™ precisa mudar o que acontece quando o quadrado √© clicado. O componente <em>Board</em> agora armazena quais quadrados est√£o preenchidos, o que quer dizer que precisamos de alguma forma do <em>Square</em> atualizar o estado do <em>Board</em>. Como o estado do componente √© considerado privado, n√£o podemos atualizar o estado do <em>Board</em> diretamente do <em>Square</em>.</p>
<p>O padr√£o comum aqui √© passar uma fun√ß√£o do <em>Board</em> para o <em>Square</em> que √© chamado quando quadrado √© clicado. Modifique o m√©todo <code>renderSquare</code> do <em>Board</em> novamente para se parecer com isso:</p>
<pre><code>  renderSquare(i) {
    return (
      &lt;Square
        value={this.state.squares[i]}
        onClick={() =&gt; this.handleClick(i)}
      /&gt;
    );
  }</code></pre>
<p>N√≥s dividimos o elemento retornado em m√∫ltiplas linhas para facilitar a leitura, ent√£o adicionamos par√™nteses em torno para que o JavaScript n√£o insira um ponto-e-v√≠rgula depois do <code>return</code> e quebre nosso c√≥digo.</p>
<p>Agora passamos abaixo duas props do <em>Board</em> para o <em>Square</em>: <code>value</code> e <code>onClick</code>. O √∫ltimo √© a fun√ß√£o que o <em>Square</em> pode chamar. Vamos fazer as seguintes mudan√ßas no <em>Square</em>:</p>
<ul>
<li>Substitua <code>this.state.value</code> com <code>this.props.value</code> no <code>render</code> do <em>Square</em>.</li>
<li>Substitua <code>this.setState()</code> com <code>this.props.onClick()</code> no render do <em>Square</em>.</li>
<li>Remova o construtor do <em>Square</em> pois n√£o vamos ter mais estado.</li>
</ul>
<p>Depois dessas mudan√ßas, o componente <em>Square</em> deve se parecer com isso:</p>
<pre><code>class Square extends React.Component {
  render() {
    return (
      &lt;button className=&#34;square&#34; onClick={() =&gt; this.props.onClick()}&gt;
        {this.props.value}
      &lt;/button&gt;
    );
  }
}</code></pre>
<p>Agora, quando o quadrado √© clicado, ele chama a fun√ß√£o onClick que √© passada pelo <em>Board</em>. Vamos recapitular o que acontece aqui:</p>
<ol type="1" start="1">
<li>A prop <code>onClick</code> do componente da DOM <code>&lt;button&gt;</code> chama o React para configurar um ouvinte de evento clique.</li>
<li>Quando o bot√£o √© clicado, o React chama o receptor de evento <code>onClick</code> definido no m√©todo <code>render()</code> do <em>Square</em>.</li>
<li>Este evento chama <code>this.props.onClick()</code>. As props do <em>Square</em> s√£o especificadas pelo <em>Board</em>.</li>
<li>O <em>Board</em> passa <code>onClick={() =&gt; this.handleClick(i)}</code> para o <em>Square</em>, ent√£o quando chamado, ele executa <code>this.handleClick(i)</code> no <em>Board</em>.</li>
<li>N√≥s n√£o definimos ainda o m√©todo <code>handleClick()</code> no <em>Board</em> ainda, ent√£o nosso c√≥digo quebra.</li>
</ol>
<p>Repare que o evento <code>onClick</code> do elemento <code>&lt;button&gt;</code> do DOM tem um significado especial no React, mas n√≥s podemos nomear a prop <code>onClick</code> do <em>Square</em> ou o <code>handleClick</code> do <em>Board</em> de forma diferente. Contudo, a conven√ß√£o no React √© de usar nomes para atributos <code>on*</code> e <code>handle*</code> para os m√©todos receptores de eventos.</p>
<p>Tente clicar num quadrado - voc√™ deve receber um erro, pois n√£o definimos o <code>handleClick</code> ainda. Adicione-o √† classe <em>Board</em>.</p>
<pre><code>class Board extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      squares: Array(9).fill(null),
    };
  }

  handleClick(i) {
    const squares = this.state.squares.slice();
    squares[i] = &#39;X&#39;;
    this.setState({squares: squares});
  }

  renderSquare(i) {
    return (
      &lt;Square
        value={this.state.squares[i]}
        onClick={() =&gt; this.handleClick(i)}
      /&gt;
    );
  }

  render() {
    const status = &#39;Pr√≥ximo jogador: X&#39;;

    return (
      &lt;div&gt;
        &lt;div className=&#34;status&#34;&gt;{status}&lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        &lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        &lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<p>N√≥s chamamos o m√©todo <code>.slice()</code> para copiar a lista <code>squares</code> ao inv√©s de modificar a lista existente. Pule para a se√ß√£o seguinte para entender por qu√™ a imutabilidade √© importante.</p>
<p>Agora n√≥s devemos ser capazes de clicar em um quadrado para preench√™-lo novamente, mas o estado √© armazenado no componente <em>Board</em> ao inv√©s de cada <em>Square</em>, o que nos permite continuar a construir nosso jogo. Note que sempre que o estado do <em>Board</em> √© modificado, os componentes <em>Square</em> s√£o re-renderizados automaticamente.</p>
<p>O <em>Square</em> n√£o mant√©m seu pr√≥prio estado mais; ele recebe o valor do seu pai <em>Board</em> e informa o pai quando √© clicado. Chamamos isso de <strong>componentes controlados</strong>.</p>
<h2>Por qu√™ a imutabilidade √© importante</h2>
<p>No c√≥digo de exemplo anterior, sugerimos usar o operator <code>.slice()</code> para copiar a lista <code>squares</code> antes de fazer uma mudan√ßa e evitar de modificar a lista existente. Vamos falar sobre o que isso quer dizer e por que √© importante aprender esse conceito.</p>
<p>H√° geralmente duas formas de modificar dados. O primeiro m√©todo √© <strong>modificar</strong> os dados diretamente modificando os valores de uma vari√°vel. O segundo m√©todo √© <strong>substituir</strong> os dados com uma nova c√≥·πïia do objeto que tamb√©m inclua as modifica√ß√µes desejadas.</p>
<h3><strong>Modificando dados com muta√ß√£o</strong></h3>
<pre><code>var player = {score: 1, name: &#39;Jeff&#39;};
player.score = 2;
// Agora player √© {score: 2, name: &#39;Jeff&#39;}</code></pre>
<h3><strong>Modificando dados sem muta√ß√£o</strong></h3>
<pre><code>var player = {score: 1, name: &#39;Jeff&#39;};

var newPlayer = Object.assign({}, player, {score: 2});
// Agora o player √© alterado, mas o novo jogador √© {score: 2, name: &#39;Jeff&#39;}

// Ou se voc√™ quer usar a sintaxe de esparramar de objeto, voc√™ pode escrever:
// var newPlayer = {...player, score: 2};</code></pre>
<p>O resultado final √© o mesmo, mas ao n√£o modificar (ou trocar os dados internos) diretamente, n√≥s agora temos um benef√≠cio adicional que pode ajudar a aumentar a performance do componente e da aplica√ß√£o no geral.</p>
<h3><strong>Facilita Desfazer/Refazer e Viagem no Tempo</strong></h3>
<p>Imutabilidade tamb√©m torna features complexas mais f√°ceis de implementar. Por exemplo, mais a frente nesse tutorial n√≥s vamos implementar a viagem no tempo entre diferentes est√°gioso do jogo. Evitar muta√ß√µes nos permite manter refer√™ncias para vers√µes antigas dos dados, e trocar entre elas se for necess√°rio.</p>
<h3><strong>Rastrear mudan√ßas</strong></h3>
<p>Determinar se um objeto foi modificado √© complexo, pois modifica√ß√µes s√£o feitas diretamente no objeto. Isso ent√£o requer comparar o objeto atual com uma c√≥pia anterior, atravessar toda a estrutura do objeto, e comparar cada vari√°vel e valor. Esse processo pode se tornar incrivelmente complexo.</p>
<p>Determinar como um objeto imut√°vel foi modificado √© muito mais f√°cil. Se o objeto sendo referenciado √© diferente do anterior, ent√£o o objeto mudou. √â isso. (No JavaScript, objetos e array s√£o passados por refer√™ncia, logo comparar essa refer√™ncia [ponteiro] √© r√°pido e simples)</p>
<h3><strong>Determinar quando Re-renderizar no React</strong></h3>
<p>O maior benef√≠cio da imutabilidade em React vem quando voc√™ quer construir <em>componentes puros</em>. Como a imutabilidade dos dados facilita a determina√ß√£o se mudan√ßas foram feitas, ela tamb√©m ajuda a determinar quando um componente requer re-renderiza√ß√£o.</p>
<p>Para aprender mais sobre <code>shouldComponentUpdate()</code> e como construir <em>componentes puros</em>, d√™ uma olhada em <a href="https://reactjs.org/docs/optimizing-performance.html#examples" target="_blank">Otimizando a Performance</a>.</p>
<h2><strong>Componentes Funcionais</strong></h2>
<p>N√≥s removemos o construtor, e de fato, o React suporta uma sintaxe mais simples chamada <strong>componentes funcionais</strong> para componentes como o <em>Square</em> que s√≥ consistem de um m√©todo <code>render</code>. Ao inv√©s de definir uma classe estendendo <code>React.Component</code>, uma simples fun√ß√£o que recebe props e retorna o que deve ser renderizado.</p>
<p>Substitua a classe <em>Square</em> com essa fun√ß√£o:</p>
<pre><code>function Square(props) {
  return (
    &lt;button className=&#34;square&#34; onClick={props.onClick}&gt;
      {props.value}
    &lt;/button&gt;
  );
}</code></pre>
<p>Voc√™ vai precisar mudar <code>this.props</code> para <code>props</code> ambas as vezes que ele aparece. Muitos componentes em suas apps poder√£o ser escritas como componentes funcionais: esses componentes tendem a ser mais f√°ceis de escrever e o React vai otimiz√°-los mais no futuro.</p>
<p>Enquanto est√°vamos arrumando o c√≥digo, tamb√©m mudamos <code>onClick={() =&gt; props.onClick()}</code> para apenas <code>onClick={props.onClick}</code>, passando a fun√ß√£o adiante √© o suficiente para nosso exemplo. Note que <code>onClick={props.onClick()}</code> n√£o vai funcionar pois ele vai chamar <code>props.onClick</code> imediatamente ao inv√©s de pass√°-lo.</p>
<h2><strong>Tomando as rodadas</strong></h2>
<p>Um defeito √≥bvio no nosso jogo √© que somente X pode jogar. Vamos arrumar isso.</p>
<p>Vamos tornar padr√£o que o primeiro movimento seja do ‚ÄòX&#39;. Modifique o estado inicial no construtor do <em>Board</em>:</p>
<pre><code>class Board extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      squares: Array(9).fill(null),
      xIsNext: true,
    };
  }</code></pre>
<p>Cada vez que mudarmos uma c√©lula, devemos mudar <code>xIsNext</code> trocando o valor booleano ao salvar o estado. Agora atualize o <code>handleClick</code> do <em>Board</em> para modificar o valor de <code>xIsNext</code>:</p>
<pre><code>  handleClick(i) {
    const squares = this.state.squares.slice();
    squares[i] = this.state.xIsNext ? &#39;X&#39; : &#39;O&#39;;
    this.setState({
      squares: squares,
      xIsNext: !this.state.xIsNext,
    });
  }</code></pre>
<p>Agora X e O tomam turnos. Depois, modificamos o texto de &#34;status&#34; no m√©todo <code>render</code> do <em>Board</em> para tamb√©m mostrar quem √© o pr√≥ximo:</p>
<pre><code>  render() {
    const status = &#39;Pr√≥ximo jogador: &#39; + (this.state.xIsNext ? &#39;X&#39; : &#39;O&#39;);

    return (
      // o resto n√£o √© modificado</code></pre>
<p>Depois dessas mudan√ßas voc√™ deve ter este componente <em>Board</em>:</p>
<pre><code>class Board extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      squares: Array(9).fill(null),
      xIsNext: true,
    };
  }

  handleClick(i) {
    const squares = this.state.squares.slice();
    squares[i] = this.state.xIsNext ? &#39;X&#39; : &#39;O&#39;;
    this.setState({
      squares: squares,
      xIsNext: !this.state.xIsNext,
    });
  }

  renderSquare(i) {
    return (
      &lt;Square
        value={this.state.squares[i]}
        onClick={() =&gt; this.handleClick(i)}
      /&gt;
    );
  }

  render() {
    const status = &#39;Next player: &#39; + (this.state.xIsNext ? &#39;X&#39; : &#39;O&#39;);

    return (
      &lt;div&gt;
        &lt;div className=&#34;status&#34;&gt;{status}&lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        &lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        &lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<h2><strong>Declarando o vencedor</strong></h2>
<p>Vamos mostrar quando o jogo √© vencido. Adicione essa fun√ß√£o auxiliar no final do arquivo:</p>
<pre><code>function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i &lt; lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}</code></pre>
<p>Voc√™ pode cham√°-la no m√©todo <code>render</code> do <em>Board</em> para verificar se algu√©m venceu o jogo e modificar o texto de status para &#34;Vencedor: [X/O]&#34;.</p>
<pre><code>render() {
    const winner = calculateWinner(this.state.squares);
    let status;
    if (winner) {
      status = &#39;Vencedor: &#39; + winner;
    } else {
      status = &#39;Pr√≥ximo jogador: &#39; + (this.state.xIsNext ? &#39;X&#39; : &#39;O&#39;);
    }

    return (
      // o resto n√£o foi modificado</code></pre>
<p>Agora pode alterar o <code>handleClick</code> no <em>Board</em> para ignorar o clique caso algu√©m tenha ganho o jogo ou se o quadrado j√° estiver preenchido:</p>
<pre><code>  handleClick(i) {
    const squares = this.state.squares.slice();
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    squares[i] = this.state.xIsNext ? &#39;X&#39; : &#39;O&#39;;
    this.setState({
      squares: squares,
      xIsNext: !this.state.xIsNext,
    });
  }</code></pre>
<p>Parab√©ns! Voc√™ agora tem um jogo da velha funcional. E agora voc√™ sabe o b√°sico do React. Ent√£o <em>voc√™</em> provavelmente √© o verdadeiro vencedor aqui.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Armazenando o hist√≥rico" duration="0">
        <p>Vamos tornar poss√≠vel revisitar estados antigos do jogo para que possamos v√™-lo em movimentos anteriores. J√° criamos uma nova lista squares a cada movimento, o que quer dizer que podemos armazenar facilmente o passado do jogo simultaneamente.</p>
<p>Vamos armazenar um objeto como esse no estado:</p>
<pre><code>history = [
  {
    squares: [
      null, null, null,
      null, null, null,
      null, null, null,
    ]
  },
  {
    squares: [
      null, null, null,
      null, &#39;X&#39;, null,
      null, null, null,
    ]
  },
  // ...
]</code></pre>
<p>Queremos que um componente de alto n√≠vel <em>Game</em> seja respons√°vel por exibir a lista de movimentos. Ent√£o quando movemos o estado do <em>Square</em> no <em>Board</em>, vamos fazer a mesma coisa do <em>Board</em> para o <em>Game</em> - ent√£o teremos todas as informa√ß√µes que precisamos no n√≠vel mais alto.</p>
<p>Primeiro, definimos o estado inicial do <em>Game</em> adicionando um construtor nele:</p>
<pre><code>class Game extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      history: [{
        squares: Array(9).fill(null),
      }],
      xIsNext: true,
    };
  }

  render() {
    return (
      &lt;div className=&#34;game&#34;&gt;
        &lt;div className=&#34;game-board&#34;&gt;
          &lt;Board /&gt;
        &lt;/div&gt;
        &lt;div className=&#34;game-info&#34;&gt;
          &lt;div&gt;{/* status */}&lt;/div&gt;
          &lt;ol&gt;{/* TODO */}&lt;/ol&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<p>Ent√£o modifique o <em>Board</em> de tal forma que receba <code>squares</code> via props e seu pr√≥prio <code>onClick</code> especificado pelo <em>Game</em>, como fizemos com o <em>Square</em> antes. Voc√™ pode passar a localiza√ß√£o de cada quadrado no receptor do click, para sabermos qual quadrado foi clicado. Aqui est√° uma lista dos passos necess√°rios:</p>
<ul>
<li>Remover o construtor do <em>Board</em>.</li>
<li>Substituir <code>this.state.squares[i]</code> com <code>this.props.squares[i]</code> no <code>renderSquare</code> do <em>Board</em>.</li>
<li>Substituir <code>this.handleClick(i)</code> com <code>this.props.onClick(i)</code> no <code>renderSquare</code> do <em>Board</em>.</li>
</ul>
<p>Agora o componente <em>Board</em> inteiro se parece com isso:</p>
<pre><code>class Board extends React.Component {
  handleClick(i) {
    const squares = this.state.squares.slice();
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    squares[i] = this.state.xIsNext ? &#39;X&#39; : &#39;O&#39;;
    this.setState({
      squares: squares,
      xIsNext: !this.state.xIsNext,
    });
  }

  renderSquare(i) {
    return (
      &lt;Square
        value={this.props.squares[i]}
        onClick={() =&gt; this.props.onClick(i)}
      /&gt;
    );
  }

  render() {
    const winner = calculateWinner(this.state.squares);
    let status;
    if (winner) {
      status = &#39;Vencedor: &#39; + winner;
    } else {
      status = &#39;Pr√≥ximo jogador: &#39; + (this.state.xIsNext ? &#39;X&#39; : &#39;O&#39;);
    }

    return (
      &lt;div&gt;
        &lt;div className=&#34;status&#34;&gt;{status}&lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        &lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        &lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<p>O m√©todo render do <em>Game</em> deve olhar para a entrada mais recente do hist√≥rico e calcular o estado do jogo:</p>
<pre><code>  render() {
    const history = this.state.history;
    const current = history[history.length - 1];
    const winner = calculateWinner(current.squares);

    let status;
    if (winner) {
      status = &#39;Vencedor: &#39; + winner;
    } else {
      status = &#39;Pr√≥ximo jogador: &#39; + (this.state.xIsNext ? &#39;X&#39; : &#39;O&#39;);
    }

    return (
      &lt;div className=&#34;game&#34;&gt;
        &lt;div className=&#34;game-board&#34;&gt;
          &lt;Board
            squares={current.squares}
            onClick={(i) =&gt; this.handleClick(i)}
          /&gt;

        &lt;/div&gt;
        &lt;div className=&#34;game-info&#34;&gt;
          &lt;div&gt;{status}&lt;/div&gt;
          &lt;ol&gt;{/* TODO */}&lt;/ol&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }</code></pre>
<p>Como o <em>Game</em> est√° renderizando o estado, podemos remover <code>&lt;div className=&#34;status&#34;&gt;{status}&lt;/div&gt;</code> e o c√≥digo de c√°lculo do estado do m√©todo <code>render</code> do <em>Board</em>:</p>
<pre><code>  render() {
    return (
      &lt;div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        &lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        &lt;/div&gt;
        &lt;div className=&#34;board-row&#34;&gt;
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }</code></pre>
<p>Em seguida, precisamos mover o m√©todo <code>handleClick</code> do <em>Board</em> para o <em>Game</em>. Voc√™ pode cort√°-lo da classe <em>Board</em> e col√°-lo na classe <em>Game</em>.</p>
<p>Tamb√©m precisamos mud√°-lo um pouco, pois o estado do <em>Game</em> √© estruturado de forma diferente. O <code>handleClick</code> do <em>Game</em> pode criar uma nova entrada na pilha concatenando um novo hist√≥rico e criando uma nova lista:</p>
<pre><code>  handleClick(i) {
    const history = this.state.history;
    const current = history[history.length - 1];
    const squares = current.squares.slice();
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    squares[i] = this.state.xIsNext ? &#39;X&#39; : &#39;O&#39;;
    this.setState({
      history: history.concat([{
        squares: squares,
      }]),
      xIsNext: !this.state.xIsNext,
    });
  }</code></pre>
<p>Nesse ponto, o <em>Board</em> s√≥ precisa do <code>renderSquare</code> e <code>render</code>. A inicializa√ß√£o do estado e recep√ß√£o do clique devem ambos vir do <em>Game</em>.</p>
<h2><strong>Mostrando os movimentos</strong></h2>
<p>Vamos mostrar os movimentos anteriores do jogo at√© ent√£o. Aprendemos que os elementos do React s√£o objetos JavaScript que podemos armazenar ou passar por a√≠. Para renderizar m√∫ltiplos itens no React, passamos uma lista de elementos React. A forma mais comum de fazer isso √© mapear de uma lista de dados. Vamos fazer isso no m√©todo <code>render</code> do <em>Game</em>:</p>
<pre><code>  render() {
    const history = this.state.history;
    const current = history[history.length - 1];
    const winner = calculateWinner(current.squares);

    const moves = history.map((step, move) =&gt; {
      const desc = move ?
        &#39;Voltar ao movimento #&#39; + move :
        &#39;Voltar ao come√ßo do jogo&#39;;
      return (
        &lt;li&gt;
          &lt;button onClick={() =&gt; this.jumpTo(move)}&gt;{desc}&lt;/button&gt;
        &lt;/li&gt;
      );
    });

    let status;
    if (winner) {
      status = &#39;Vencedor: &#39; + winner;
    } else {
      status = &#39;Pr√≥ximo jogador: &#39; + (this.state.xIsNext ? &#39;X&#39; : &#39;O&#39;);
    }

    return (
      &lt;div className=&#34;game&#34;&gt;
        &lt;div className=&#34;game-board&#34;&gt;
          &lt;Board
            squares={current.squares}
            onClick={(i) =&gt; this.handleClick(i)}
          /&gt;
        &lt;/div&gt;
        &lt;div className=&#34;game-info&#34;&gt;
          &lt;div&gt;{status}&lt;/div&gt;
          &lt;ol&gt;{moves}&lt;/ol&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }</code></pre>
<p>Para cada passo no hist√≥rico, vamos criar um item <code>&lt;li&gt;</code> com um <code>&lt;button&gt;</code> dentro que tem um receptor de click que vamos implementar daqui a pouco. Com esse c√≥digo, voc√™ deve ver uma lista de movimentos que foram feitos no jogo, junto com um aviso que diz:</p>
<aside class="warning"><p><strong>Warning: Each child in an array or iterator should have a unique &#34;key&#34; prop. Check the render method of &#34;Game&#34;.</strong></p>
</aside>
<p>(Aviso: cada filho de uma lista ou iterador deve ter uma propriedade &#34;chave&#34; √∫nica. Verifique o m√©todo render do <em>Game</em>.)</p>
<p>Vamos falar sobre o que esse aviso quer dizer.</p>
<h2><strong>Chaves</strong></h2>
<p>Quando renderizamos uma lista de itens, o React sempre armazena alguma informa√ß√£o sobre cada item na lsita. Se voc√™ renderiza um componente que tem estado, esse estado precisa ser armazenado - e independente de como voc√™ implementa seus componentes, o React armazena refer√™ncia para os elementos nativos.</p>
<p>Quando voc√™ atualiza uma lista, o React precisa determinar o que mudou. Voc√™ pode ter adicionado, removido, reorganizado, ou atualizado itens na lista.</p>
<p>Imagine a transi√ß√£o de</p>
<pre><code>&lt;li&gt;Alex: 7 tarefas restantes&lt;/li&gt;
&lt;li&gt;Benjamin: 5 tarefas restantes&lt;/li&gt;</code></pre>
<p>para</p>
<pre><code>&lt;li&gt;Benjamin: 9 tarefas restantes&lt;/li&gt;
&lt;li&gt;Claudia: 8 tarefas restantes&lt;/li&gt;
&lt;li&gt;Alex: 5 tarefas restantes&lt;/li&gt;</code></pre>
<p>Para o olho humano, parece que Alex e Benjamin trocaram de lugar e Claudia foi adicionada - mas o React √© um programa de computador e n√£o sabe o que voc√™ quer fazer. Como resultado, o React pede para especificar uma propriedade <em>key</em> em cada elemento da lista, um texto para diferenciar cada componente de seus pares. Nesse caso, <code>alex</code>, <code>benjamin</code> e <code>claudia</code> seriam boas chaves; se esses itens correspondem a objetos no banco de dados, o ID do registro geralmente √© uma boa escolha:</p>
<pre><code>&lt;li key={user.id}&gt;{user.name}: {user.taskCount} tarefas restantes&lt;/li&gt;</code></pre>
<p><code>key</code> tem uma fun√ß√£o especial que √© reservada pelo React (assim como <code>ref</code>, um recurso mais avan√ßado). Quando um elemento √© criado, o React pega a propriedade <code>key</code> e a armazena no pr√≥prio elemento (nativo). Apesar de parecer parte da lista de props, ela n√£o pode ser referenciada como <code>this.props.key</code>. O React usa a chave automaticamente para decidir que filhos atualizar; n√£o h√° uma forma do pr√≥prio componente saber sua chave.</p>
<p>Quando a lista √© re-renderizada, o React pega cada elemento da nova vers√£o e olha por uma propriedade chave que combine com a lista anterior. Quando a chave √© adicionada ao conjunto, o componente √© criado; quando a chave √© removida, o componente √© destru√≠do. Chaves dizer ao React a identidade de cada componente, ent√£o ele pode manter o estado atrav√©s de re-renderiza√ß√µes. Se voc√™ modificar a chave de um componente, ele ser√° completamente destru√≠do e recriado com um novo estado.</p>
<p><strong>√â fortemente recomendado que voc√™ atribua chaves sempre que criar listas din√¢micas.</strong> Se voc√™ n√£o tem uma propriedade chave na m√£o, voc√™ deve considerar reestruturar seus dados para t√™-la.</p>
<p>Se voc√™ n√£o especificar qualquer chave, o React vai avis√°-lo que est√° usando o √≠ndice da lista como chave - que n√£o √© correto se voc√™ quiser reordenar os elementos da lista ou adicionar/remover itens em qualquer ao inv√©s do final da lista. Explicitamente passando <code>key={i}</code> silencia o aviso mas mant√©m o mesmo problema, ent√£o n√£o √© recomendado na maior parte dos casos.</p>
<p>Chaves de componentes n√£o precisam ser globalmente √∫nicas, somente em rela√ß√µes ao pares imediatos.</p>
<h2><strong>Implementando a viagem no tempo</strong></h2>
<p>Para nossa lista de movimentos, j√° temos um ID √∫nico para cada passo: o n√∫mero do movimento quando ele acontece. No m√©todo <code>render</code> do <em>Game</em>, adicionar como chave <code>&lt;li key={move}&gt;</code> e o aviso sobre as chaves deve desaparecer:</p>
<pre><code>    const moves = history.map((step, move) =&gt; {
      const desc = move ?
        &#39;Voltar ao movimento #&#39; + move :
        &#39;Voltar ao come√ßo do jogo&#39;;
      return (
        &lt;li key={move}&gt;
          &lt;button onClick={() =&gt; this.jumpTo(move)}&gt;{desc}&lt;/button&gt;
        &lt;/li&gt;
      );
    });</code></pre>
<p>Clicando em qualquer bot√£o gera um erro devido a <code>jumpTo</code> ser <em>undefined</em>. Vamos adicionar uma chave ao estado do <em>Game</em> indicando que passo estamos visualizando atualmente.</p>
<p>Primeiro adicione <code>stepNumber: 0</code> ao estado inicial do construtor de <em>Game</em>:</p>
<pre><code>class Game extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      history: [{
        squares: Array(9).fill(null),
      }],
      stepNumber: 0,
      xIsNext: true,
    };
  }</code></pre>
<p>Em seguida, vamos definir o m√©todo <code>jumpTo</code> no <em>Game</em> para atualizar o estado. Tamb√©m vamos atualizar <code>xIsNext</code>. Vamos definir <code>xIsNext</code> para verdadeiro se o √≠ndice do movimento for par.</p>
<pre><code>  handleClick(i) {
    // esse m√©todo n√£o mudou
  }

  jumpTo(step) {
    this.setState({
      stepNumber: step,
      xIsNext: (step % 2) === 0,
    });
  }

  render() {
    // esse m√©todo n√£o mudou
  }</code></pre>
<p>Ent√£o atualize <code>stepNumber</code> quando um novo movimento √© feito adicionando <code>stepNumber: history.length</code> √† atualiza√ß√£o do estado no <code>handleClick</code> do <em>Game</em>. Vamos atualizar o <code>handleClick</code> para ficar ciente do <code>stepNumber</code> quando ler o estado atual do tabuleiro atual para que voc√™ possa voltar no tempo e clicar no tabuleiro para criar uma nova entrada:</p>
<pre><code>  handleClick(i) {
    const history = this.state.history.slice(0, this.state.stepNumber + 1);
    const current = history[history.length - 1];
    const squares = current.squares.slice();
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    squares[i] = this.state.xIsNext ? &#39;X&#39; : &#39;O&#39;;
    this.setState({
      history: history.concat([{
        squares: squares
      }]),
      stepNumber: history.length,
      xIsNext: !this.state.xIsNext,
    });
  }</code></pre>
<p>Agora podemos modificar o <code>render</code> do <em>Game</em> para ler um estado do hist√≥rico:</p>
<pre><code>  render() {
    const history = this.state.history;
    const current = history[this.state.stepNumber];
    const winner = calculateWinner(current.squares);

    // o resto n√£o mudou</code></pre>
<p>Se voc√™ clicar em qualquer bot√£o agora, o tabuleiro deve imediatamente atualizar para exibir como o jogo se parecia naquele momento.</p>
<h2><strong>Recapitulando</strong></h2>
<p>Agora, temos um jogo da velha que:</p>
<ul>
<li>Permite voc√™ jogar o <em>jogo da velha</em>;</li>
<li>Indica qual jogador ganhou o jogo;</li>
<li>Armazena o hist√≥rico de movimentos durante o jogo;</li>
<li>Permite os jogadores voltar no tempo para ver vers√µes anteriores do jogo.</li>
</ul>
<p>Bom trabalho! Esperamos que voc√™ sinta que tem um bom entendimento de como o React funciona.</p>
<p>Se voc√™ tiver tempo extra e quiser praticar novas habilidades, aqui est√£o algumas ideias para melhorias que voc√™ pode fazer, listadas em ordem de dificuldade:</p>
<ol type="1" start="1">
<li>Exibir a localiza√ß√£o de cada movimento no formato (coluna, linha) no hist√≥rico.</li>
<li>Exibir em negrito o item selecionado na lista de movimentos.</li>
<li>Reescrever o <em>Board</em> para usar dois loops para criar os quadrados ao inv√©s de <em>hard-codar</em> eles.</li>
<li>Adicionar um bot√£o para alternar a ordem dos movimentos em ascendente ou descendente.</li>
<li>Quando algu√©m vencer, destacar os tr√™s quadrados que causaram o ganho.</li>
<li>Quando ningu√©m vencer, mostrar uma mensagem sobre o resultado.</li>
</ol>
<p>Atrav√©s deste tutorial, tocamos em um n√∫mero de conceitos do React, incluindo elementos, componentes, props e estado. Para uma explica√ß√£o mais detalhada de cada t√≥pico, olhe na <a href="https://reactjs.org/docs/hello-world.html" target="_blank">documenta√ß√£o oficial</a> (em ingl√™s). Para aprender mais sobre como definir componentes, verifique a <a href="https://reactjs.org/docs/react-component.html" target="_blank">refer√™ncia da API React.Component</a>.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-120783401-1', 'auto');

    (function() {
      var gaCodelab = '';
      if (gaCodelab) {
        ga('create', gaCodelab, 'auto', {name: 'codelab'});
      }

      var gaView;
      var parts = location.search.substring(1).split('&');
      for (var i = 0; i < parts.length; i++) {
        var param = parts[i].split('=');
        if (param[0] === 'viewga') {
          gaView = param[1];
          break;
        }
      }
      if (gaView && gaView !== gaCodelab) {
        ga('create', gaView, 'auto', {name: 'view'});
      }
    })();
  </script>

</body>
</html>
